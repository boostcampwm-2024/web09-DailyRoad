import {
  ClusterStats,
  Marker,
  MarkerClusterer,
  MarkerClustererEvents,
  MarkerClustererOptions,
  MarkerUtils,
  SuperClusterViewportAlgorithm,
} from '@googlemaps/markerclusterer';
import { clusterMarkerRender } from './clusterMarkerRender';

export class CustomMarkerClusterer extends MarkerClusterer {
  lastGroupMarkers: Marker[];
  markerLatLngSet: Set<string>;
  constructor(options: MarkerClustererOptions) {
    super(options);
    this.lastGroupMarkers = [];
    this.markerLatLngSet = new Set();
  }

  public onAdd(): void {
    const map = this.getMap();
    if (!map) return;
    this.idleListener = map.addListener('idle', () => {
      this.render();
    });
    this.render();
  }

  public addMarker(
    marker: google.maps.marker.AdvancedMarkerElement,
    noDraw?: boolean,
  ): void {
    const markerLatLng = `${marker.position?.lat} ${marker.position?.lng}`;
    if (this.markerLatLngSet.has(markerLatLng)) {
      return;
    }

    this.markers.push(marker);
    this.markerLatLngSet.add(markerLatLng);

    if (!noDraw) {
      this.render();
    }
  }

  public removeMarker(
    marker: google.maps.marker.AdvancedMarkerElement,
    noDraw?: boolean,
  ): boolean {
    const index = this.markers.indexOf(marker);
    if (index === -1) {
      // Marker is not in our list of markers, so do nothing:
      return false;
    }

    const markerLatLng = `${marker.position?.lat} ${marker.position?.lng}`;
    this.markerLatLngSet.delete(markerLatLng);

    MarkerUtils.setMap(marker, null);
    this.markers.splice(index, 1); // Remove the marker from the list of managed markers

    if (!noDraw) {
      this.render();
    }

    return true;
  }

  public render(): void {
    const map = this.getMap();
    if (map instanceof google.maps.Map && map.getProjection()) {
      google.maps.event.trigger(
        this,
        MarkerClustererEvents.CLUSTERING_BEGIN,
        this,
      );
      const { clusters, changed } = this.algorithm.calculate({
        markers: this.markers,
        map,
        mapCanvasProjection: this.getProjection(),
      });
      console.log(changed, 'changed');
      // Allow algorithms to return flag on whether the clusters/markers have changed.
      if (changed || changed === undefined) {
        // Accumulate the markers of the clusters composed of a single marker.
        // Those clusters directly use the marker.
        // Clusters with more than one markers use a group marker generated by a renderer.
        const singleMarker = new Set<Marker>();
        for (const cluster of clusters) {
          if (cluster.markers?.length === 1) {
            singleMarker.add(cluster.markers[0]);
          }
        }

        const groupMarkers: Marker[] = [];
        // Iterate the clusters that are currently rendered.
        for (const cluster of this.clusters) {
          if (cluster.marker === null) {
            continue;
          }
          if (cluster.markers?.length === 1) {
            if (!singleMarker.has(cluster.marker!)) {
              // The marker:
              // - was previously rendered because it is from a cluster with 1 marker,
              // - should no more be rendered as it is not in singleMarker.
              MarkerUtils.setMap(cluster.marker!, null);
            }
          } else {
            // Delay the removal of old group markers to avoid flickering.
            groupMarkers.push(cluster.marker!);
          }
        }

        this.clusters = clusters;
        this.renderClusters();
        // Delayed removal of the markers of the former groups.

        setTimeout(() => {
          groupMarkers.forEach((marker) => {
            MarkerUtils.setMap(marker, null);
          });
        }, 35);
      }
      google.maps.event.trigger(
        this,
        MarkerClustererEvents.CLUSTERING_END,
        this,
      );
    }
  }

  protected renderClusters(): void {
    // Generate stats to pass to renderers.
    const stats = new ClusterStats(this.markers, this.clusters);

    const map = this.getMap() as google.maps.Map;

    this.clusters.forEach((cluster) => {
      if (cluster.markers?.length === 1) {
        cluster.marker = cluster.markers[0];
      } else {
        // Generate the marker to represent the group.
        cluster.marker = this.renderer.render(cluster, stats, map);
        // Make sure all individual markers are removed from the map.
        cluster.markers?.forEach((marker) => MarkerUtils.setMap(marker, null));
        if (this.onClusterClick) {
          cluster.marker.addListener(
            'click',
            /* istanbul ignore next */
            (event: google.maps.MapMouseEvent) => {
              google.maps.event.trigger(
                this,
                MarkerClustererEvents.CLUSTER_CLICK,
                cluster,
              );
              this.onClusterClick(event, cluster, map);
            },
          );
        }
      }
      MarkerUtils.setMap(cluster.marker, map);
    });
  }
}

export const clustererOptions = {
  algorithm: new SuperClusterViewportAlgorithm({ maxZoom: 18 }),
  renderer: {
    render: clusterMarkerRender,
  },
};
