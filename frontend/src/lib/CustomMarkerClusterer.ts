import {
  Cluster,
  ClusterStats,
  Marker,
  MarkerClusterer,
  MarkerClustererEvents,
  MarkerClustererOptions,
  MarkerUtils,
  SuperClusterViewportAlgorithm,
} from '@googlemaps/markerclusterer';
import { clusterMarkerRender } from './clusterMarkerRender';

export class CustomMarkerClusterer extends MarkerClusterer {
  lastGroupMarkers: Marker[];
  markerLatLngSet: Set<string>;
  constructor(options: MarkerClustererOptions) {
    super(options);
    this.lastGroupMarkers = [];
    this.markerLatLngSet = new Set();
  }

  public addMarker(
    marker: google.maps.marker.AdvancedMarkerElement,
    noDraw?: boolean,
  ): void {
    const markerLatLng = `${marker.position?.lat}${marker.position?.lng}`;
    if (this.markerLatLngSet.has(markerLatLng)) {
      return;
    }

    this.markers.push(marker);
    this.markerLatLngSet.add(markerLatLng);

    if (!noDraw) {
      this.render();
    }
  }

  public render(): void {
    const map = this.getMap();
    if (map instanceof google.maps.Map && map.getProjection()) {
      google.maps.event.trigger(
        this,
        MarkerClustererEvents.CLUSTERING_BEGIN,
        this,
      );
      const { clusters, changed } = this.algorithm.calculate({
        markers: this.markers,
        map,
        mapCanvasProjection: this.getProjection(),
      });

      // Allow algorithms to return flag on whether the clusters/markers have changed.
      if (changed || changed === undefined) {
        // Accumulate the markers of the clusters composed of a single marker.
        // Those clusters directly use the marker.
        // Clusters with more than one markers use a group marker generated by a renderer.
        const singleMarker = new Set<Marker>();
        for (const cluster of clusters) {
          if (cluster.markers?.length === 1) {
            singleMarker.add(cluster.markers[0]);
          }
        }

        const groupMarkers: Marker[] = [];
        // Iterate the clusters that are currently rendered.
        for (const cluster of this.clusters) {
          if (cluster.marker === null) {
            continue;
          }
          if (cluster.markers?.length === 1) {
            if (!singleMarker.has(cluster.marker!)) {
              // The marker:
              // - was previously rendered because it is from a cluster with 1 marker,
              // - should no more be rendered as it is not in singleMarker.
              console.log('cluster.marker removed', cluster.marker);
              MarkerUtils.setMap(cluster.marker!, null);
            }
          } else {
            // Delay the removal of old group markers to avoid flickering.
            groupMarkers.push(cluster.marker!);
          }
        }

        this.clusters = clusters;
        this.renderClusters();
        // Delayed removal of the markers of the former groups.
        console.log('groupMarkers', groupMarkers);
        setTimeout(() => {
          groupMarkers.forEach((marker) => {
            MarkerUtils.setMap(marker, null);
          });
        }, 35);
      }
      google.maps.event.trigger(
        this,
        MarkerClustererEvents.CLUSTERING_END,
        this,
      );
    }
  }
}

export const clustererOptions = {
  algorithm: new SuperClusterViewportAlgorithm({ maxZoom: 18 }),
  renderer: {
    render: clusterMarkerRender,
  },
};
