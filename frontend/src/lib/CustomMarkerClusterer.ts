import {
  Cluster,
  ClusterStats,
  Marker,
  MarkerClusterer,
  MarkerClustererEvents,
  MarkerClustererOptions,
  MarkerUtils,
  SuperClusterViewportAlgorithm,
} from '@googlemaps/markerclusterer';
import { clusterMarkerRender } from './clusterMarkerRender';

export class CustomMarkerClusterer extends MarkerClusterer {
  lastGroupMarkers: Marker[];
  constructor(options: MarkerClustererOptions) {
    super(options);
    this.lastGroupMarkers = [];
  }
  public render(): void {
    const map = this.getMap();
    if (map instanceof google.maps.Map && map.getProjection()) {
      google.maps.event.trigger(
        this,
        MarkerClustererEvents.CLUSTERING_BEGIN,
        this,
      );
      const { clusters, changed } = this.algorithm.calculate({
        markers: this.markers,
        map,
        mapCanvasProjection: this.getProjection(),
      });

      // Allow algorithms to return flag on whether the clusters/markers have changed.
      if (changed || changed === undefined) {
        // Accumulate the markers of the clusters composed of a single marker.
        // Those clusters directly use the marker.
        // Clusters with more than one markers use a group marker generated by a renderer.
        const singleMarker = new Set<Marker>();
        for (const cluster of clusters) {
          if (cluster.markers?.length === 1) {
            singleMarker.add(cluster.markers[0]);
          }
        }

        const groupMarkers: Marker[] = [];
        // Iterate the clusters that are currently rendered.
        for (const cluster of this.clusters) {
          if (cluster.marker === null) {
            continue;
          }
          if (cluster.markers?.length === 1) {
            if (!singleMarker.has(cluster.marker!)) {
              // The marker:
              // - was previously rendered because it is from a cluster with 1 marker,
              // - should no more be rendered as it is not in singleMarker.
              MarkerUtils.setMap(cluster.marker!, null);
            }
          } else {
            // Delay the removal of old group markers to avoid flickering.
            groupMarkers.push(cluster.marker!);
          }
        }

        this.clusters = clusters;
        this.renderClusters();
        // Delayed removal of the markers of the former groups.
        setTimeout(() => {
          groupMarkers.forEach((marker) => {
            MarkerUtils.setMap(marker, null);
          });
        }, 35);
      }
      google.maps.event.trigger(
        this,
        MarkerClustererEvents.CLUSTERING_END,
        this,
      );
    }
  }
}

export const clustererOptions = {
  algorithm: new SuperClusterViewportAlgorithm({ maxZoom: 18 }),
  renderer: {
    render: clusterMarkerRender,
  },
};
